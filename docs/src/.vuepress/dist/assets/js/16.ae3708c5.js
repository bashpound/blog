(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{389:function(t,a,s){"use strict";s.r(a);var r=s(25),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"투영-기하학과-물체-인식-알고리즘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#투영-기하학과-물체-인식-알고리즘"}},[t._v("#")]),t._v(" 투영 기하학과 물체 인식 알고리즘")]),t._v(" "),s("h2",{attrs:{id:"두-번째-임무"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#두-번째-임무"}},[t._v("#")]),t._v(" 두 번째 임무")]),t._v(" "),s("p",[t._v("AI&Web 개발자라는 타이틀에 맞게 나에게 내려진 두 번째 임무는 라벨 인식 알고리즘 개발이었다. 어찌보면 "),s("a",{attrs:{href:"https://bashpound.github.io/article/idx.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("SI성격이 강한 국가 과제 프로젝트는"),s("OutboundLink")],1),t._v(" 2021년 1월부터는 외주로 운영된다 하여 향후 PM이 될 준비 과정이라고 생각하면 되고, 내 진짜 업무는 이 알고리즘과 벡터 변환법을 개발하여 특허를 출원하는 것이었다. AI 팀에서 내 역할은 리서치 및 주요 변환 모듈 개발. 각종 선형 변환 법을 생각하게 되었고 처음 시도했던 방향은 reverse 3D 모델링 혹은 딥러닝.. 성능이 감당되지 않을 것 같다는 생각에 쉽게 가자 라는 결론에 도달하여 정공법보단 잔머리를 쓰기 시작했다.")]),t._v(" "),s("h2",{attrs:{id:"문제의-인식"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#문제의-인식"}},[t._v("#")]),t._v(" 문제의 인식")]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/kc.jpg",alt:"책상 위의 케첩"}})]),s("p",{attrs:{align:"middle"}},[t._v("\n케첩의 라벨로부터 정보를 어떻게 얻어낼 수 있을까?\n")]),s("p"),t._v(" "),s("p",[t._v("라벨 인식을 그냥 하라는 말은 당연히 아니었다. (텐서플로우 튜토리얼엔 공식적으로 MNIST 글자 인식 알고리즘을 통째로 제공하고 있으며 그냥 갔다 쓰면 될 일이기 때문이다.), 사용자들이 라벨을 딱 예쁘게 찍어서 올리면 얼마나 좋을까. 하지만 현실은 그렇지 않다. 사용자가 아무리 예쁘게 찍어도 글씨는 기울어지게 되어있다. 라벨은 곡면 위에 인쇄되어있기 때문이다. 그리고 이는 인식률에 치명적이다. 나에게 주어진 임무는 라벨이 예쁘게 찍히지 않았을 경우, 즉 곡면 위의 글자를 인식할 상황을 고려해야 했었다. 당연히 시중에 나와있는 모델로는 불가능한 상황. "),s("s",[t._v("그래야 특허가 나오잖아")])]),t._v(" "),s("h2",{attrs:{id:"투영-기하학"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#투영-기하학"}},[t._v("#")]),t._v(" 투영 기하학")]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/coordinates.png",alt:"3축 좌표계와 2축 좌표계"}})]),s("p",{attrs:{align:"middle"}},[t._v("\n3차원 좌표계와 2차원 좌표계\n")]),s("p"),t._v(" "),s("p",[t._v("3D좌표계가 주어졌을 경우, 2차원 좌표계로 이를 나타내기는 쉽다. 문제는 2D에서 3D좌표를 복원하는 일, 왜냐하면 이미지는 2D 정보만을 담고 있기 때문이다. 이 평면 정보로부터 3D좌표 관계를 추정해야 한다. 왜냐하면 물체의 크기 사이에는 물리법칙이 적용되니까. 인간이 사진이라는 2D 이미지만 보고도 충분한 원근감을 느끼듯 컴퓨터에게도 원근감을 느낄 수 있도록 인간 세상의 물리법칙을 입력해주어야 한다.")]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/octahedral.png",alt:"octahedral"}})]),s("p",{attrs:{align:"middle"}},[t._v("\n다양한 시점에서의 정팔면체(왼쪽부터 투영의 중심 상위, 투영의 중심, 투영의 중심 하위 시점)\n")]),s("p"),t._v(" "),s("p",[t._v("정팔면체의 모든 면은 정삼각형으로 이루어져있고, 보는 시점에 따라 길이가 다르게 투영되어 보인다. 시점이 투영의 중심에 있을 때 정삼각형이라면, 위 혹은 아래에서 봤을 경우 마주보는 면의 높이가 작아진다. 무엇보다 본 그림은 자바스크립트로 3D모델링을 할 수 있도록 구현된 모듈에서 따온 것이다. 누군가가 구현을 했다는 것은 어떠한 규칙이 있다는 것이고, 그 규칙을 이해하기 위해서는 투영 기하학을 이해해야 한다.")]),t._v(" "),s("h2",{attrs:{id:"응시의-기하학적-의미"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#응시의-기하학적-의미"}},[t._v("#")]),t._v(" 응시의 기하학적 의미")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),s("p",[t._v("물체를 응시할 때 느끼는 크기는 관찰점에서 그 물체를 수직 투영한 평면상 그림자의 크기에 비례한다.")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/pointofview.png",alt:"pointofview"}})]),s("p",{attrs:{align:"middle"}},[t._v("\n응시의 기하학적 의미\n")]),s("p"),t._v(" "),s("p",[t._v("물체를 응시했을때 느끼는 크기는 관찰점을 투영의 중심으로 그 물체를 투영한 사물의 크기와 비례한다. (삼각형을 관찰점과 가까이 그리고, 멀리 있다고 생각해보자. 투영면이 커지고 작아질 것이다.) 붉은 선이 물체를 통과하는 점은 투영의 중심으로 관찰점과 직교하는 점이다. (무게 중심 등과 햇갈릴 수 있는데, 물체가 가지는 정보와는 아무런 상관이 없고 오직 시선과 직교하는 물체 표면 위의 한 점이 바로 투영의 중심이다.")]),t._v(" "),s("p",[t._v("이 도표로부터 비례관계를 얻어낼 수가 있다. 그리고 그 관계로부터 어떤 물체가 있을 때, 이것이 실제로 어떻게 생겼는지 추측할 수 있다.")]),t._v(" "),s("h2",{attrs:{id:"tangential-왜곡의-변환-행렬"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tangential-왜곡의-변환-행렬"}},[t._v("#")]),t._v(" Tangential 왜곡의 변환 행렬")]),t._v(" "),s("p",[t._v("다음에")])])}),[],!1,null,null,null);a.default=e.exports}}]);