(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{387:function(t,e,a){"use strict";a.r(e);var r=a(25),i=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"flux-dataflow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flux-dataflow"}},[t._v("#")]),t._v(" Flux dataflow")]),t._v(" "),a("h2",{attrs:{id:"상태-관리"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#상태-관리"}},[t._v("#")]),t._v(" 상태 관리")]),t._v(" "),a("p",[t._v("웹 페이지를 구축하다 보면, 상태 관리에 대한 이슈에 직면하게 된다.")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Note:")]),t._v(" "),a("p",[t._v("사용자 관점의 상태 관리란 유스케이스의 전 과정에서 사용자 경험에 필요한 모든 정보들을 논리적으로 무결하게 설계하는 것을 말한다.")])]),t._v(" "),a("p",[t._v("기본적으로 HTML은 정적 프로토콜 즉, 페이지 간에 어떠한 정보도 공유하지 않는다. 그런 프로토콜 안에 로그인된 사용자가 누군지, 쇼핑몰의 경우 어떤 물건을 보고 장바구니에 넣었는지에 대한 정보 등 http 요청에 관계없이 웹 서비스의 라이프사이클 안에 반드시 저장되어야 하는 정보들을 논리적으로 정의하고 그 정보를 이용하는 것이 상태관리의 핵심이라 할 수 있겠다.")]),t._v(" "),a("p",[t._v("가장 원시적인 상태 관리는 유스케이스(Route, Page view)등 의 이동 단위마다 이전 데이터의 정보를 그대로 전송하는 것에서 시작한다. 당연히 어플리케이션의 규모가 조금만 커져도 데이터 흐름 다이어그램을 기술할 수 없을 정도로 복잡해지기 때문에 보통의 상태 관리는 Spring등의 프레임워크를 이용하여 컨테이너 형태 혹은 컨테이너와 세션이 결합된 형태로 중앙 컨테이너에서 뽑아 쓰는 형태로 활용한다.")]),t._v(" "),a("p",[t._v("사용자의 시점에서 상태 관리는 세션에서 시작한다. 이는 웹페이지가 사용자를 구분하는 것에서부터 시작한다는 의미이다. 이 구분은 트랜잭션이 발생할 경우 매우 중대해진다. 하지만 세션 안에 저장할 수 있는 정보는 한계가 있다. 따라서 고수준의 웹 서비스를 구현하기 위해 다양한 상태 관리 기법이 등장했다. Flux dataflow도 그 중 하나로써 Facebook이 발표한 데이터 패턴이다. 다음의 링크는 페이스북에서 공식 발표한 introduction이니 참고하자.")]),t._v(" "),a("p",{staticClass:"media",attrs:{align:"middle"}},[a("iframe",{attrs:{width:"360",height:"240",src:"https://www.youtube.com/embed/nYkdrAPrdcw",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:""}}),a("br"),t._v(" Facebook - FLUX dataflow\n")]),t._v(" "),a("h2",{attrs:{id:"basic-lifecycle-둘러보기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#basic-lifecycle-둘러보기"}},[t._v("#")]),t._v(" Basic Lifecycle - 둘러보기")]),t._v(" "),a("p",[t._v("Flux 패턴의 가장 큰 특징은 단방향 흐름이라는 것이고 Flux 패턴의 의의라고 강조하고 있다. 각 노드들은 고유의 입/출력을 가지고 있으며 독립적이다. Action은 데이터 타입 및 데이터를 포함한 경량의 객체이다. User interaction은 view에서 이뤄지는데,  이는 새로운 액션을 전파한다. 즉,")]),t._v(" "),a("mermaid",{attrs:{align:"middle"}},[t._v("\n%%{init: {'theme': 'neutral', 'themeVariables': { 'primaryColor': '#ff0000'}}}%%\ngraph LR\n    A[Action] --\x3e B[Dispatcher] --\x3e C[Store] --\x3e D[View]\n")]),t._v(" "),a("h3",{attrs:{id:"lifecycle-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lifecycle-1"}},[t._v("#")]),t._v(" Lifecycle #1")]),t._v(" "),a("p",[t._v("위 라이프사이클이 무한히 반복되는 것과 추상적 개념이 같다.")]),t._v(" "),a("mermaid",{attrs:{align:"middle"}},[t._v("\n%%{init: {'theme': 'forest', 'themeVariables': { 'primaryColor': '#ff0000'}}}%%\ngraph LR\n    A[Action] --\x3e B[Dispatcher] --\x3e C[Store] --\x3e D[View]\n    D[View] --\x3e B[Dispatcher]\n")]),t._v(" "),a("h3",{attrs:{id:"lifecycle-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lifecycle-2"}},[t._v("#")]),t._v(" Lifecycle #2")]),t._v(" "),a("p",[t._v("위는 새로운 액션이 적극적으로 전파될 수도 있음을 의미한다. 쉽게 말해, Action이 일어나면  View 가 송출되고,  View에서 다시 사용자의 인터렉션에 의해 Action이 발생되고 이것이 반복되는 흐름을 말한다. 여기까지는 다른 데이터흐름 모델과 크게 다를 것이 없다. 중요한 것은 단방향 흐름을 강제함으로써 데이터 흐름을 직관적으로 이해할 수 있게끔 설계하는 것, 그리고 나머지는 Dispatcher와 Store의 역할이다.")]),t._v(" "),a("h2",{attrs:{id:"async-funtional-reactive-programming"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async-funtional-reactive-programming"}},[t._v("#")]),t._v(" Async funtional reactive programming")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Note:")]),t._v(" "),a("p",[t._v("This structure allows us to reason easily about our application in a way that is reminiscent of "),a("em",[t._v("functional reactive programming")]),t._v(", or more specifically "),a("em",[t._v("data-flow programming")]),t._v(" or "),a("em",[t._v("flow-based programming")]),t._v(", where data flows through the application in a single direction // "),a("a",{attrs:{href:"http://facebook.github.io/flux/docs/in-depth-overview",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://facebook.github.io/flux/docs/in-depth-overview"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("모든 Action은 Store 에 전달된다. 이 작업은 Dispatcher의 콜백에 의해 이뤄진다. Store는 어플리케이션의 모든 상태를 보유하고 있는 싱글톤 객체이고 Dispatcher 는 Store의 조작에 관련된 로직을 분리해놓은 또 하나의 싱글톤 객체이다. Dispatcher는 등록 된 콜백을 특정 순서로 호출하여 저장소 간 종속성을 관리하는 데 사용될 객체로 어플레케이션의 규모가 커질 때 제 역할을 한다고 볼 수 있다.")]),t._v(" "),a("h2",{attrs:{id:"mvc-pattern"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvc-pattern"}},[t._v("#")]),t._v(" MVC pattern?")]),t._v(" "),a("p",[t._v("Flux 패턴이 MVC와 도대체 무엇이 다른지 궁금해질 타이밍이 왔다. 하지만 분명 명확한 차이점이 있다. 데이터가 한 방향으로 전파된다는 점, 그리고 비동기적 상태 변화 등. 이러한 특징들이 기존 MVC패턴과 대비해 어떤 중대한 위력을 발휘하는지는 아래 영상에서 자세히 설명하고 있으니 참고하자.")]),t._v(" "),a("p",{staticClass:"media",attrs:{align:"middle"}},[a("iframe",{attrs:{width:"360",height:"240",src:"https://www.youtube.com/embed/Bic_sFiaNDI",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:""}}),t._v(" "),a("br"),t._v(" React and Flux\n ")])],1)}),[],!1,null,null,null);e.default=i.exports}}]);